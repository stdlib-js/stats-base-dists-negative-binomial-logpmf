{"version":3,"file":"index.mjs","sources":["../lib/ibeta_derivative.js","../lib/ibeta_power_terms.js","../lib/main.js","../lib/factory.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport ibetaPowerTerms from './ibeta_power_terms.js' ;\n\n\n// MAIN //\n\n/**\n* Computes the partial derivative with respect to x of the incomplete beta function.\n*\n* @private\n* @param {Probability} x - input value (0 < x <= 1)\n* @param {PositiveNumber} a - first parameter\n* @param {PositiveNumber} b - second parameter (must be greater than 1)\n* @returns {number} value of the partial derivative\n*/\nfunction ibetaDerivative( x, a, b ) {\n\tvar f1;\n\tvar y;\n\tif ( x === 1.0 ) {\n\t\treturn 0.0;\n\t}\n\t// Regular cases:\n\tf1 = ibetaPowerTerms( a, b, x, 1.0 - x, true );\n\ty = ( 1.0 - x ) * x;\n\tf1 /= y;\n\treturn f1;\n}\n\n\n// EXPORTS //\n\nexport default ibetaDerivative;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/special_functions/beta.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright John Maddock 2006.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport lanczosSumExpGScaled from '@stdlib/math-base-special-gamma-lanczos-sum-expg-scaled' ;\nimport expm1 from '@stdlib/math-base-special-expm1' ;\nimport log1p from '@stdlib/math-base-special-log1p' ;\nimport sqrt from '@stdlib/math-base-special-sqrt' ;\nimport abs from '@stdlib/math-base-special-abs' ;\nimport exp from '@stdlib/math-base-special-exp' ;\nimport pow from '@stdlib/math-base-special-pow' ;\nimport max from '@stdlib/math-base-special-max' ;\nimport min from '@stdlib/math-base-special-min' ;\nimport ln from '@stdlib/math-base-special-ln' ;\nimport MAX_LN from '@stdlib/constants-float64-max-ln' ;\nimport MIN_LN from '@stdlib/constants-float64-min-ln' ;\nimport G from '@stdlib/constants-float64-gamma-lanczos-g' ;\nimport E from '@stdlib/constants-float64-e' ;\n\n\n// MAIN //\n\n/**\n* Computes the leading power terms in the incomplete beta function.\n*\n* When normalized,\n*\n* ```tex\n* \\frac{ x^a y^b }{ \\operatorname{Beta}(a,b) }\n* ```\n*\n* and otherwise\n*\n* ```tex\n* x^a y^b\n* ```\n*\n* ## Notes\n*\n* -   Almost all of the error in the incomplete beta comes from this function, particularly when \\\\( a \\\\) and \\\\( b \\\\) are large. Computing large powers are _hard_ though, and using logarithms just leads to horrendous cancellation errors.\n*\n* -   For \\\\( l1 * l2 > 0 \\\\) or \\\\( \\operatorname{min}( a, b ) < 1 \\\\), the two power terms both go in the same direction (towards zero or towards infinity). In this case if either term overflows or underflows, then the product of the two must do so also. Alternatively, if one exponent is less than one, then we can't productively use it to eliminate overflow or underflow from the other term.  Problems with spurious overflow/underflow can't be ruled out in this case, but it is _very_ unlikely since one of the power terms will evaluate to a number close to 1.\n*\n* -   If \\\\( \\max( \\abs(l1), \\abs(l2) ) < 0.5 \\\\), both exponents are near one and both the exponents are greater than one, and, further, these two power terms tend in opposite directions (one toward zero, the other toward infinity), so we have to combine the terms to avoid any risk of overflow or underflow. We do this by moving one power term inside the other, we have:\n*\n*     ```tex\n*     (1 + l_1)^a \\cdot (1 + l_2)^b \\\\\n*     = ((1 + l_1) \\cdot (1 + l_2)^(b/a))^a \\\\\n*     = (1 + l_1 + l_3 + l_1*l_3)^a\n*     ```\n*\n*     and\n*\n*     ```tex\n*     l_3 = (1 + l_2)^(b/a) - 1 \\\\\n*     = \\exp((b/a) * \\ln(1 + l_2)) - 1\n*     ```\n*\n*     The tricky bit is deciding which term to move inside. By preference we move the larger term inside, so that the size of the largest exponent is reduced.  However, that can only be done as long as l3 (see above) is also small.\n*\n* @private\n* @param {NonNegativeNumber} a - function parameter\n* @param {NonNegativeNumber} b - function parameter\n* @param {Probability} x - function parameter\n* @param {Probability} y - probability equal to `1-x`\n* @param {boolean} normalized - boolean indicating whether to evaluate the power terms of the regularized or non-regularized incomplete beta function\n* @returns {number} power terms\n*/\nfunction ibetaPowerTerms( a, b, x, y, normalized ) {\n\tvar result;\n\tvar smallA;\n\tvar ratio;\n\tvar agh;\n\tvar bgh;\n\tvar cgh;\n\tvar l1;\n\tvar l2;\n\tvar l3;\n\tvar p1;\n\tvar b1;\n\tvar b2;\n\tvar c;\n\tvar l;\n\n\tif ( !normalized ) {\n\t\t// Can we do better here?\n\t\treturn pow( x, a ) * pow( y, b );\n\t}\n\tc = a + b;\n\n\t// Combine power terms with Lanczos approximation:\n\tagh = a + G - 0.5;\n\tbgh = b + G - 0.5;\n\tcgh = c + G - 0.5;\n\tresult = lanczosSumExpGScaled( c );\n\tresult /= lanczosSumExpGScaled( a ) * lanczosSumExpGScaled( b );\n\n\t// Combine with the leftover terms from the Lanczos approximation:\n\tresult *= sqrt( bgh / E );\n\tresult *= sqrt( agh / cgh );\n\n\t// `l1` and `l2` are the base of the exponents minus one:\n\tl1 = ( ( x * b ) - ( y * agh ) ) / agh;\n\tl2 = ( ( y * a ) - ( x * bgh ) ) / bgh;\n\tif ( min( abs(l1), abs(l2) ) < 0.2 ) {\n\t\t// When the base of the exponent is very near 1 we get really gross errors unless extra care is taken:\n\t\tif ( l1 * l2 > 0 || min( a, b ) < 1 ) {\n\t\t\tif ( abs(l1) < 0.1 ) {\n\t\t\t\tresult *= exp( a * log1p( l1 ) );\n\t\t\t} else {\n\t\t\t\tresult *= pow( ( x*cgh ) / agh, a );\n\t\t\t}\n\t\t\tif ( abs(l2) < 0.1 ) {\n\t\t\t\tresult *= exp( b * log1p( l2 ) );\n\t\t\t} else {\n\t\t\t\tresult *= pow((y * cgh) / bgh, b);\n\t\t\t}\n\t\t}\n\t\telse if ( max( abs(l1), abs(l2) ) < 0.5 ) {\n\t\t\tsmallA = a < b;\n\t\t\tratio = b / a;\n\t\t\tif (\n\t\t\t\t(smallA && (ratio * l2 < 0.1)) ||\n\t\t\t\t(!smallA && (l1 / ratio > 0.1))\n\t\t\t) {\n\t\t\t\tl3 = expm1( ratio * log1p( l2 ) );\n\t\t\t\tl3 = l1 + l3 + ( l3 * l1 );\n\t\t\t\tl3 = a * log1p( l3 );\n\t\t\t\tresult *= exp( l3 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl3 = expm1( log1p( l1 ) / ratio );\n\t\t\t\tl3 = l2 + l3 + ( l3 * l2 );\n\t\t\t\tl3 = b * log1p( l3 );\n\t\t\t\tresult *= exp( l3 );\n\t\t\t}\n\t\t}\n\t\telse if ( abs(l1) < abs(l2) ) {\n\t\t\t// First base near 1 only:\n\t\t\tl = ( a * log1p( l1 ) ) + ( b * ln( ( y*cgh ) / bgh ) );\n\t\t\tif ( l <= MIN_LN || l >= MAX_LN ) {\n\t\t\t\tl += ln(result);\n\t\t\t\tif ( l >= MAX_LN ) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t}\n\t\t\t\tresult = exp( l );\n\t\t\t} else {\n\t\t\t\tresult *= exp( l );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Second base near 1 only:\n\t\t\tl = ( b * log1p( l2 ) ) + ( a * ln( (x*cgh) / agh ) );\n\t\t\tif ( l <= MIN_LN || l >= MAX_LN ) {\n\t\t\t\tl += ln(result);\n\t\t\t\tif ( l >= MAX_LN ) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t}\n\t\t\t\tresult = exp( l );\n\t\t\t} else {\n\t\t\t\tresult *= exp( l );\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// General case:\n\t\tb1 = (x * cgh) / agh;\n\t\tb2 = (y * cgh) / bgh;\n\t\tl1 = a * ln(b1);\n\t\tl2 = b * ln(b2);\n\t\tif (\n\t\t\tl1 >= MAX_LN ||\n\t\t\tl1 <= MIN_LN ||\n\t\t\tl2 >= MAX_LN ||\n\t\t\tl2 <= MIN_LN\n\t\t) {\n\t\t\t// Oops, under/overflow, sidestep if we can:\n\t\t\tif ( a < b ) {\n\t\t\t\tp1 = pow( b2, b / a );\n\t\t\t\tl3 = a * ( ln(b1) + ln(p1) );\n\t\t\t\tif ( l3 < MAX_LN && l3 > MIN_LN ) {\n\t\t\t\t\tresult *= pow( p1 * b1, a );\n\t\t\t\t} else {\n\t\t\t\t\tl2 += l1 + ln(result);\n\t\t\t\t\tif ( l2 >= MAX_LN ) {\n\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t}\n\t\t\t\t\tresult = exp( l2 );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp1 = pow( b1, a / b );\n\t\t\t\tl3 = ( ln(p1) + ln(b2) ) * b;\n\t\t\t\tif ( l3 < MAX_LN && l3 > MIN_LN ) {\n\t\t\t\t\tresult *= pow( p1 * b2, b );\n\t\t\t\t} else {\n\t\t\t\t\tl2 += l1 + ln( result );\n\t\t\t\t\tif (l2 >= MAX_LN) {\n\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t}\n\t\t\t\t\tresult = exp( l2 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Finally the normal case:\n\t\t\tresult *= pow( b1, a ) * pow( b2, b );\n\t\t}\n\t}\n\treturn result;\n}\n\n\n// EXPORTS //\n\nexport default ibetaPowerTerms;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isnan from '@stdlib/math-base-assert-is-nan' ;\nimport isNonNegativeInteger from '@stdlib/math-base-assert-is-nonnegative-integer' ;\nimport ln from '@stdlib/math-base-special-ln' ;\nimport NINF from '@stdlib/constants-float64-ninf' ;\nimport ibetaDerivative from './ibeta_derivative.js' ;\n\n\n// MAIN //\n\n/**\n* Evaluates the natural logarithm of the probability mass function (PMF) for a negative binomial distribution with number of successes until experiment is stopped `r` and success probability `p`.\n*\n* @param {number} x - input value\n* @param {PositiveNumber} r - number of successes until experiment is stopped\n* @param {Probability} p - success probability\n* @returns {number} evaluated logPMF\n*\n* @example\n* var y = logpmf( 5.0, 20.0, 0.8 );\n* // returns ~-1.853\n*\n* @example\n* var y = logpmf( 21.0, 20.0, 0.5 );\n* // returns ~-2.818\n*\n* @example\n* var y = logpmf( 5.0, 10.0, 0.4 );\n* // returns ~-4.115\n*\n* @example\n* var y = logpmf( 0.0, 10.0, 0.9 );\n* // returns ~-1.054\n*\n* @example\n* var y = logpmf( 21.0, 15.5, 0.5 );\n* // returns ~-3.292\n*\n* @example\n* var y = logpmf( 5.0, 7.4, 0.4 );\n* // returns ~-2.976\n*\n* @example\n* var y = logpmf( 2.0, 0.0, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = logpmf( 2.0, -2.0, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = logpmf( 2.0, 20, -1.0 );\n* // returns NaN\n*\n* @example\n* var y = logpmf( 2.0, 20, 1.5 );\n* // returns NaN\n*\n* @example\n* var y = logpmf( NaN, 20.0, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = logpmf( 0.0, NaN, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = logpmf( 0.0, 20.0, NaN );\n* // returns NaN\n*/\nfunction logpmf( x, r, p ) {\n\tif (\n\t\tisnan( x ) ||\n\t\tisnan( r ) ||\n\t\tisnan( p ) ||\n\t\tr <= 0.0 ||\n\t\tp <= 0.0 ||\n\t\tp > 1.0\n\t) {\n\t\treturn NaN;\n\t}\n\tif ( !isNonNegativeInteger( x ) || p === 0.0 ) {\n\t\treturn NINF;\n\t}\n\treturn ln( p ) - ln( r + x ) + ln( ibetaDerivative( p, r, x + 1.0 ) );\n}\n\n\n// EXPORTS //\n\nexport default logpmf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isNonNegativeInteger from '@stdlib/math-base-assert-is-nonnegative-integer' ;\nimport constantFunction from '@stdlib/utils-constant-function' ;\nimport isnan from '@stdlib/math-base-assert-is-nan' ;\nimport ln from '@stdlib/math-base-special-ln' ;\nimport NINF from '@stdlib/constants-float64-ninf' ;\nimport ibetaDerivative from './ibeta_derivative.js' ;\n\n\n// MAIN //\n\n/**\n* Returns a function for evaluating the natural logarithm of the probability mass function (PMF) for a negative binomial distribution with number of successes until experiment is stopped `r` and success probability `p`.\n*\n* @param {PositiveNumber} r - number of successes until experiment is stopped\n* @param {Probability} p - success probability\n* @returns {Function} logPMF\n*\n* @example\n* var logpmf = factory( 10, 0.5 );\n* var y = logpmf( 3.0 );\n* // returns ~-3.617\n*\n* y = logpmf( 5.0 );\n* // returns ~-2.795\n*/\nfunction factory( r, p ) {\n\tif (\n\t\tisnan( r ) ||\n\t\tisnan( p ) ||\n\t\tr <= 0.0 ||\n\t\tp <= 0.0 ||\n\t\tp > 1.0\n\t) {\n\t\treturn constantFunction( NaN );\n\t}\n\treturn logpmf;\n\n\t/**\n\t* Evaluates the natural logarithm of the probability mass function (PMF) for a negative binomial distribution.\n\t*\n\t* @private\n\t* @param {number} x - input value\n\t* @returns {number} evaluated logPMF\n\t*\n\t* @example\n\t* var y = logpmf( 2.0 );\n\t* // returns <number>\n\t*/\n\tfunction logpmf( x ) {\n\t\tif ( isnan( x ) ) {\n\t\t\treturn NaN;\n\t\t}\n\t\tif ( !isNonNegativeInteger( x ) ) {\n\t\t\treturn NINF;\n\t\t}\n\t\treturn ln( p ) - ln( r + x ) + ln( ibetaDerivative( p, r, x + 1.0 ) );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default factory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Natural logarithm of the probability mass function (PMF) for a negative binomial distribution.\n*\n* @module @stdlib/stats-base-dists-negative-binomial-logpmf\n*\n* @example\n* import logpmf from '@stdlib/stats-base-dists-negative-binomial-logpmf' ;\n*\n* var y = logpmf( 5.0, 20.0, 0.8 );\n* // returns ~-1.853\n*\n* y = logpmf( 21.0, 20.0, 0.5 );\n* // returns ~-2.818\n*\n* y = logpmf( 5.0, 10.0, 0.4 );\n* // returns ~-4.115\n*\n* y = logpmf( 0.0, 10.0, 0.9 );\n* // returns ~-1.054\n*\n* y = logpmf( 21.0, 15.5, 0.5 );\n* // returns ~-3.292\n*\n* y = logpmf( 5.0, 7.4, 0.4 );\n* // returns ~-2.976\n*\n* var mylogpmf = logpmf.factory( 10, 0.5 );\n* y = mylogpmf( 3.0 );\n* // returns ~-3.612\n*\n* y = mylogpmf( 5.0 );\n* // returns ~-2.797\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property' ;\nimport main from './main.js' ;\nimport factory from './factory.js' ;\n\n\n// MAIN //\n\nsetReadOnly( main, 'factory', factory );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["ibetaDerivative","x","a","b","f1","y","normalized","result","smallA","ratio","agh","bgh","cgh","l1","l2","l3","p1","b1","b2","c","l","pow","G","lanczosSumExpGScaled","sqrt","E","min","abs","exp","log1p","max","expm1","ln","MIN_LN","MAX_LN","NaN","ibetaPowerTerms","logpmf","r","p","isnan","isNonNegativeInteger","NINF","factory","constantFunction","setReadOnly","main"],"mappings":"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"}